name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches:
      - "**" # Match all branches

jobs:
  ai-review:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: |
          npm install @octokit/rest axios
      
      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            **/*.js
            **/*.jsx
            **/*.ts
            **/*.tsx
            **/*.py
            **/*.java
            **/*.cpp
            **/*.c
            **/*.cs
            **/*.go
            **/*.rs
            **/*.php
            **/*.rb
            **/*.yml
            **/*.yaml
          separator: ' '
      
      - name: Debug Context
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"
          echo "SHA: ${{ github.sha }}"
          echo "Ref: ${{ github.ref }}"
      
      - name: Run AI Code Review
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          node --input-type=module - <<'EOF'
          import fs from 'fs';
          import path from 'path';
          import { Octokit } from '@octokit/rest';
          import axios from 'axios';

          const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
          const changedFiles = process.env.CHANGED_FILES?.split(' ') || [];
          const context = JSON.parse(process.env.GITHUB_CONTEXT || '{}');

          // Debug: Print context to see what we're getting
          console.log('=== DEBUG: Context Analysis ===');
          console.log('Event name:', context.event_name);
          console.log('Repository:', context.repository);
          console.log('Repository full_name:', context.repository?.full_name);
          console.log('Repository name:', context.repository?.name);
          console.log('Repository owner:', context.repository?.owner?.login);
          console.log('Actor:', context.actor);
          console.log('Ref:', context.ref);
          console.log('SHA:', context.sha);
          console.log('================================');

          const getLanguage = (ext) => ({
            '.js': 'javascript',
            '.ts': 'typescript',
            '.jsx': 'javascript',
            '.tsx': 'typescript',
            '.py': 'python',
            '.java': 'java',
            '.cpp': 'cpp',
            '.c': 'c',
            '.cs': 'csharp',
            '.go': 'go',
            '.rs': 'rust',
            '.php': 'php',
            '.rb': 'ruby',
            '.yml': 'yaml',
            '.yaml': 'yaml'
          }[ext] || 'text');

          async function analyzeCode(filePath, code) {
            const prompt = `
            Review the following ${getLanguage(path.extname(filePath))} code and return JSON:
            {
              "score": 1-10,
              "summary": "Suppose you are a senior developer reviewing this code give detailed feedback and suggestions for improvement.",
              "comments": [
                { "line": 5, "type": "bug|performance|style|security", "severity": "low|medium|high", "message": "feedback" }
              ]
            }

            Code:
            \`\`\`
            ${code}
            \`\`\`
            `;

            try {
              const res = await axios.post(
                "https://api.groq.com/openai/v1/chat/completions",
                {
                  model: "llama3-8b-8192",
                  messages: [{ role: "user", content: prompt }],
                  temperature: 0.3
                },
                {
                  headers: {
                    Authorization: `Bearer ${process.env.GROQ_API_KEY}`,
                    "Content-Type": "application/json"
                  }
                }
              );

              const content = res.data.choices[0].message.content || "";
              const match = content.match(/\{[\s\S]*\}/);

              if (match) {
                try {
                  return JSON.parse(match[0]);
                } catch {
                  console.warn("Invalid JSON from AI, using raw text as summary.");
                  return { score: 5, summary: content, comments: [] };
                }
              } else {
                return { score: 5, summary: content, comments: [] };
              }
            } catch (e) {
              console.error("Error analyzing file:", filePath, e.message);
              return { score: 0, summary: "AI analysis failed", comments: [] };
            }
          }

          async function postPRComments(reviews) {
            if (context.event_name !== 'pull_request') {
              console.warn("Not a pull request event, skipping PR comments.");
              return;
            }

            const pullRequest = context.event?.pull_request;
            if (!pullRequest) {
              console.warn("No pull request data found in context, skipping PR comments.");
              return;
            }

            // Try multiple ways to get repository info
            let owner, repo;
            
            if (context.repository?.full_name) {
              [owner, repo] = context.repository.full_name.split('/');
            } else if (context.repository?.owner?.login && context.repository?.name) {
              owner = context.repository.owner.login;
              repo = context.repository.name;
            } else {
              console.error("Cannot determine repository owner/name from context");
              return;
            }

            const prNumber = pullRequest.number;
            const commitSha = pullRequest.head.sha;

            console.log(`Posting comments to PR #${prNumber} in ${owner}/${repo}`);

            try {
              for (const review of reviews) {
                if (!review?.comments || review.comments.length === 0) continue;
                
                for (const comment of review.comments) {
                  try {
                    await octokit.pulls.createReviewComment({
                      owner,
                      repo,
                      pull_number: prNumber,
                      body: `**${comment.type?.toUpperCase() || "NOTE"} (${comment.severity || "info"})**: ${comment.message}`,
                      commit_id: commitSha,
                      path: review.filePath,
                      line: comment.line || 1,
                      side: 'RIGHT'
                    });
                    console.log(`‚úÖ Posted comment for ${review.filePath}:${comment.line || 1}`);
                  } catch (error) {
                    console.error(`‚ùå Failed to post comment for ${review.filePath}:`, error.message);
                  }
                }
              }
            } catch (error) {
              console.error("Error posting PR comments:", error.message);
            }
          }

          async function postPushIssue(reviews) {
            // Try multiple ways to get repository info
            let owner, repo;
            
            if (context.repository?.full_name) {
              [owner, repo] = context.repository.full_name.split('/');
            } else if (context.repository?.owner?.login && context.repository?.name) {
              owner = context.repository.owner.login;
              repo = context.repository.name;
            } else if (context.repositoryUrl) {
              // Extract from repository URL: git://github.com/user/repo.git
              const match = context.repositoryUrl.match(/github\.com\/([^\/]+)\/([^\/]+)\.git/);
              if (match) {
                owner = match[1];
                repo = match[2];
              }
            }

            if (!owner || !repo) {
              console.error("‚ùå Cannot determine repository owner/name from context");
              console.error("Available context keys:", Object.keys(context));
              return;
            }

            const commitSha = context.sha?.substring(0, 7) || "unknown";
            let body = `## ü§ñ AI Code Review - Commit \`${commitSha}\`\n\n`;
            
            body += `**Event:** ${context.event_name}\n`;
            body += `**Branch:** ${context.ref?.replace('refs/heads/', '') || 'unknown'}\n`;
            body += `**Author:** ${context.actor || 'unknown'}\n\n`;

            for (const r of reviews) {
              if (!r) continue;
              body += `### üìÑ \`${r.filePath}\`\n`;
              body += `**Score:** ${r.score}/10 ‚≠ê\n`;
              body += `**Summary:** ${r.summary}\n\n`;
              
              if (r.comments && r.comments.length > 0) {
                body += `**Issues Found:**\n`;
                r.comments.forEach(c => {
                  const emoji = c.severity === 'high' ? 'üö®' : c.severity === 'medium' ? '‚ö†Ô∏è' : 'üí°';
                  body += `${emoji} **${c.type?.toUpperCase()}** (${c.severity}): ${c.message}\n`;
                });
              } else {
                body += `‚úÖ **No issues found!**\n`;
              }
              body += `\n---\n`;
            }

            try {
              const issue = await octokit.issues.create({
                owner,
                repo,
                title: `ü§ñ AI Code Review - ${commitSha}`,
                body,
                labels: ['ai-review', 'code-quality']
              });
              console.log(`‚úÖ Created issue #${issue.data.number} for commit ${commitSha}`);
              console.log(`üîó Issue URL: ${issue.data.html_url}`);
            } catch (error) {
              console.error("‚ùå Error creating issue:", error.message);
            }
          }

          (async () => {
            console.log(`üöÄ Starting AI Code Review...`);
            console.log(`üìù Event: ${context.event_name}`);
            console.log(`üìÅ Changed files: ${changedFiles.join(', ')}`);
            
            if (changedFiles.length === 0) {
              console.log("‚ö†Ô∏è  No changed files found, exiting...");
              return;
            }

            let reviews = [];
            for (const filePath of changedFiles) {
              if (!fs.existsSync(filePath)) {
                console.log(`‚ö†Ô∏è  Skipping deleted file: ${filePath}`);
                continue;
              }
              
              console.log(`üîç Analyzing: ${filePath}`);
              const code = fs.readFileSync(filePath, 'utf8');
              
              // Skip very large files
              if (code.length > 50000) {
                console.log(`‚ö†Ô∏è  Skipping large file (${code.length} chars): ${filePath}`);
                continue;
              }
              
              const result = await analyzeCode(filePath, code);
              if (result) {
                result.filePath = filePath;
                reviews.push(result);
                console.log(`‚úÖ Analysis complete for ${filePath}: Score ${result.score}/10`);
              }
            }

            if (reviews.length === 0) {
              console.log("‚ö†Ô∏è  No files were analyzed, exiting...");
              return;
            }

            if (context.event_name === 'pull_request') {
              console.log("üîÑ Processing as pull request...");
              await postPRComments(reviews);
            } else {
              console.log("üîÑ Processing as push event...");
              await postPushIssue(reviews);
            }
            
            console.log("üéâ AI Code Review completed!");
          })();
          EOF
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
          GITHUB_CONTEXT: ${{ toJson(github) }}